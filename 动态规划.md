动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

# 主要思想
动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。
动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

解题思路：
- 1、定义动态数组，根据所求问题确定dp[]数组的最佳表示。**(题目问什么，就把什么定义成状态)**
- 2、使用数学归纳法写出状态转移方程，即如何由前面的结果得出后面的结果。
- 3、考虑初始条件：
    - dp数组整体的初始值
    - dp数组(二维)i=0和j=0的地方
    - dp存放状态的长度，是整个数组的长度还是数组长度加一，这点需要特别注意。
- 4、考虑输出状态
   - 返回dp数组中最后一个值作为输出，一般对应二维dp问题。
   - 返回dp数组中最大的那个数字，一般对应记录最大值问题。
   - 返回保存的最大值，一般是Maxval=max(Maxval,dp[i])这样的形式。
- 5、对时间，空间复杂度的优化（Bonus）

**模板总结**：        
```python
for i in range(len(nums)):
            for j in range(i):
                    dp[i]=最值(dp[i],dp[j]+...)
```
# 典型例题
【最长上升子序列】（力扣300）
给定一个无序的整数数组，找到其中最长上升子序列的长度。
示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
```python
'''
方法一：动态规划
'''
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
            
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        
        maxx = max(dp)
        
        return maxx
```
【注意】
1、该题目可以直接用一个一维数组dp来存储转移状态，**dp[i]可以定义为以nums[i]这个数结尾的最长递增子序列的长度**。

【最长回文子串】（力扣5）
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：
输入: "cbbd"
输出: "bb"

```python
'''
方法一：动态规划
'''
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[0 for i in range(n)] for j in range(n)]
        res = ""
        for i in range(n):
            for j in range(i+1):
                if (s[i] == s[j]) and (i-j < 2 or dp[j+1][i-1]==1):
                    dp[j][i] = 1
                    res = max(res, s[j:i+1], key = len)
        
        return res
```
【注意】
1、**dp[j][i]定义为一个二维数组，其可取值只有0和1，其代表的意思是s[j:i+1]即s中从j到i这段字符串是否是回文串。**
2、j永远小于等于i，dp[j][i]为回文串的条件是s[i] == s[j]并且
dp[j+1][i-1]也为回文串，这里用到了动态规划的思想。
3、if条件当中的i-j<2是为了考虑**边界条件**。(i-j<=2也可ac，只是这里就包含了字串长度为3（i-j==2）的情况，此时只要最外面两个字母相同，不管中间是什么字母其都是一个回文子串)即子串的长度为 1 或 2。对于长度为 1（i==j）的子串，它显然是个回文串；对于长度为 2(i - j ==1)的子串，只要它的两个字母相同，它就是一个回文串。